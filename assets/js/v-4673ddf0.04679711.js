"use strict";(self.webpackChunkgithub_io=self.webpackChunkgithub_io||[]).push([[741],{66:(n,e,t)=>{t.r(e),t.d(e,{data:()=>r});const r={key:"v-4673ddf0",path:"/guide/typescript.html",title:"TypeScript",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"基本类型",slug:"基本类型",children:[]},{level:2,title:"接口",slug:"接口",children:[]},{level:2,title:"数组的类型",slug:"数组的类型",children:[]},{level:2,title:"函数的类型",slug:"函数的类型",children:[]},{level:2,title:"类型断言",slug:"类型断言",children:[]},{level:2,title:"元组",slug:"元组",children:[]},{level:2,title:"枚举",slug:"枚举",children:[]},{level:2,title:"类",slug:"类",children:[]},{level:2,title:"泛型",slug:"泛型",children:[]},{level:2,title:"高级类型",slug:"高级类型",children:[]}],filePathRelative:"guide/typescript.md",git:{updatedTime:1632475794e3}}},5171:(n,e,t)=>{t.r(e),t.d(e,{default:()=>c});var r=t(6252);const a=(0,r._)("h1",{id:"typescript",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#typescript","aria-hidden":"true"},"#"),(0,r.Uk)(" TypeScript")],-1),i=(0,r.Uk)("大部分参考于 "),l={href:"https://ts.xcatliu.com/",target:"_blank",rel:"noopener noreferrer"},o=(0,r.Uk)("TypeScript 入门教程"),u=(0,r.uE)('<h2 id="基本类型" tabindex="-1"><a class="header-anchor" href="#基本类型" aria-hidden="true">#</a> 基本类型</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>let bool: boolean = false;  //布尔值\nlet num: number = 1;  //数值\nlet str: string = &#39;11&#39;;  //字符串\nlet nul: null = null;  //null\nconst udf: undefined = undefined;  //undefined\nlet unUse: void = undefined;  //void 严格模式下只能用 undefined，非严格模式可以是 undefined | null\nconst unionType: string | number = 1;  //联合类型\n//类型别名\ntype Str = string;\nlet str2: Str = &#39;11&#39;;  //等价于 str2: string\n</code></pre></div><h2 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>interface Person {\n    name: string;\n    age: number;\n    gender?: &quot;male&quot; | &quot;female&quot;;   //可选属性\n    [prop: string]: any;  //任意属性\n    readonly id: number;  //只读属性\n}\nconst tom: Person = {\n    id: 0,\n    name: &#39;Tom&#39;,\n    age: 10,\n    gender: &#39;male&#39;\n};\n</code></pre></div><h2 id="数组的类型" tabindex="-1"><a class="header-anchor" href="#数组的类型" aria-hidden="true">#</a> 数组的类型</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>const arr1: Array&lt;number&gt; = [1, 2];  //泛型\nconst arr2: string[] = [&#39;1&#39;, &#39;2&#39;];\n\n//数组接口  一般用于类数组，如 arguments\ninterface NumberArray {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\nconst foo = function (): void {\n    let args: NumberArray = arguments;\n    let args2: IArguments = arguments;  //TS 定义好的类型，与 NumberArray 接口形状相同\n}\n</code></pre></div><h2 id="函数的类型" tabindex="-1"><a class="header-anchor" href="#函数的类型" aria-hidden="true">#</a> 函数的类型</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>function foo1(): void { }\nfunction foo2(a: number): string { return a.toString(); }\nconst foo3 = (): void =&gt; { }\n//TS 中的 =&gt; 用来表示函数的定义  (输入) =&gt; 输出\nconst foo4: (x: number, y: number) =&gt; void = (x: number, y: number): void =&gt; { }\n\n//函数接口\ninterface IFoo {\n    (a: number, b: string, c?: number): void;\n}\nlet foo: IFoo = (a: number, b: string, c: number = 5, ...arg: Array&lt;number&gt;) =&gt; { }\n//函数重载\nfunction reverse(x: number): number;\nfunction reverse(str: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === &#39;number&#39;) {\n        return parseInt(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    } else if (typeof x === &#39;string&#39;) {\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    }\n}\n</code></pre></div><h2 id="类型断言" tabindex="-1"><a class="header-anchor" href="#类型断言" aria-hidden="true">#</a> 类型断言</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>//值 as 类型\nfunction foo(param: string | number) {\n    // console.log(param.length);  //报错，只能用 string 和 number 的公共属性\n    console.log((param as string).length);  //正常编译\n}\n</code></pre></div><h2 id="元组" tabindex="-1"><a class="header-anchor" href="#元组" aria-hidden="true">#</a> 元组</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>const tuple: [string, number] = [&#39;Tom&#39;, 10];\n</code></pre></div><h2 id="枚举" tabindex="-1"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat };\n//经过编译后 Days 为 {&quot;0&quot;: &quot;Sun&quot;, &quot;1&quot;: &quot;Mon&quot;, &quot;2&quot;: &quot;Tue&quot;, ..., &quot;Sun&quot;: 0, &quot;Mon&quot;: 1, ...}\n</code></pre></div><h2 id="类" tabindex="-1"><a class="header-anchor" href="#类" aria-hidden="true">#</a> 类</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>interface IOption {\n    name: string;\n    age: number;\n    gender: &#39;male&#39; | &#39;female&#39;;\n}\n\nclass Person {\n    public name: string;  //公有  所有属性和方法默认公有\n    private age: number;  //私有  只能在该类内部访问\n    protected gender: &#39;male&#39; | &#39;female&#39;;  //受保护  与 private 相似，但可以被子类访问\n    readonly id: number;  //只读  只能出现在属性声明或构造函数中\n\n    constructor(option: IOption) {\n        const { name, age, gender } = option;\n        this.id = Date.now();\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n}\n\nabstract class Utils {  //抽象类，不允许实例化\n    abstract sayHi(): string;  //抽象方法，由子类实现\n}\n\nclass Util extends Utils {\n    sayHi(): string {\n        return &#39;Hi&#39;;\n    }\n}\n\n\n//需要类实现的接口\ninterface Alarm {\n    alert(): void;\n}\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\ninterface LightableAlarm extends Alarm {  //接口继承\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Door { }\nclass SecurityDoor extends Door implements Alarm, Light {  //类可实现多个接口\n    alert() {\n        console.log(&#39;SecurityDoor alert&#39;);\n    }\n    lightOn() { }\n    lightOff() { }\n}\nclass CarDoor extends Door implements LightableAlarm {\n    alert() {\n        console.log(&#39;CarDoor alert&#39;);\n    }\n    lightOn() { }\n    lightOff() { }\n}\n\n//创建类的时候，会自动创建类的类型\nclass Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n//类 Point 会创建以下接口\ninterface Point {  //不会包含静态属性、方法和构造函数\n    x: number;\n    y: number;\n}\n</code></pre></div><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>//泛型 - 在定义函数、接口或类的时候，不预先指定具体的类型，使用时再指定类型\nfunction createArray(length: number, value: any): Array&lt;any&gt; {\n    return new Array(length).fill(value);\n}\n//可以预见，createArray 函数返回数组的类型与参数 value 相同，可以用泛型改写为：\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {\n    return new Array(length).fill(value);\n}\n\n//泛型约束\ninterface Lengthwise {\n    length: number;\n}\n//约束泛型T必须符合 Lengthwise 的形状 (即包含 number 类型的 length 属性)\n//泛型之间也可以互相约束 &lt;T extends U, U&gt;  这样保证了 T 的属性集包含 U 的所有属性\nfunction loggingIdentity&lt;T extends Lengwise&gt;(param: T): T {\n    console.log(param.length);\n    return param;\n}\n</code></pre></div><h2 id="高级类型" tabindex="-1"><a class="header-anchor" href="#高级类型" aria-hidden="true">#</a> 高级类型</h2><div class="language-TypeScript ext-TypeScript"><pre class="language-TypeScript"><code>interface A { a: number; }\ninterface B { b: number; }\n\n// 交叉类型，类型必须符合多个类型的形状\ntype C = A &amp; B;\nconst objC: C = { a: 1, b: 2 }; // ok\nconst objC: C = { a: 1 };  // error\n\n// 联合类型，类型需要符合某个类型的形状\nfunction f(a: number | string) {}\nf(1);  // ok\nf(&#39;a&#39;);  // ok\n\n// never 类型，用来表示不会返回的函数的返回类型\nfunction f(): never {\n    while (true) {\n        //do something\n    }\n}\n\n// typeof 取得类型\ntype T = { a: number };  // typeof T 为 { a: number }\n\n// 索引类型查询操作符 keyof 取得类型的索引\ninterface I {\n    a: number;\n    b: number;\n}\nconst a: keyof I = &#39;a&#39;;\nconst c: keyof I = &#39;c&#39;;  // error\n\n// Record 快速创建类型\n// 类型 R1 等价于 { [key: string]: any }\ntype R1 = Record&lt;string, any&gt;;\n// 类型 R2 等价于 { a: number; b: number; }\ntype R2 = Record&lt;&#39;a&#39; | &#39;b&#39;, number&gt;;\n\n// Partial 将所有属性修改为可选\n// 类型 P 等价于: { a?: number; b?: number; }\ntype P = Partial&lt;I&gt;;\n\n// Readonly 将所有属性修改为可选\n// 类型 R 等价于: { readonly a: number; readonly b: number; }\ntype R = Readonly&lt;I&gt;;\n\n// Pick 选取多组属性生成类型\n// 类型 R 等价于: { a: number; b: number; }\ntype P = Pick&lt;I, &#39;a&#39; | &#39;b&#39;&gt;;\n\n// Exclude&lt;T, U&gt; 从 T 中剔除可以赋值给 U 的类型\n// 类型 E 等价于 &#39;b&#39;\ntype E = Exclude&lt;&#39;a&#39; | &#39;b&#39;, &#39;a&#39;&gt;;\n\n// Extract&lt;T, U&gt; 提取 T 中可以赋值给 U 的类型\n// 类型 E 等价于 &#39;a&#39;\ntype E = Extract&lt;&#39;a&#39; | &#39;b&#39;, &#39;a&#39;&gt;;\n\n// NonNullable&lt;T&gt; 从 T 中去除 null 和 undefined\n// 类型 N 等价于 number | string\ntype N = NonNullable&lt;number | null | undefined | string&gt;;\n\n// ReturnType&lt;T&gt; 获取函数返回值的类型\n// 类型 P 等价于 number\nfunction f(): number { return 1; }\ntype R = ReturnType&lt;typeof f&gt;;\n\n// InstanceType&lt;T&gt; 获取构造函数类型的实例类型\n// 类型 I 等价于类型 C\nclass C {}\ntype I = InstanceType&lt;typeof C&gt;;\n\n// Omit&lt;T, U&gt; 去掉 T 中包含 U 的类型\n// 类型 O 等价于 { b: string; }\ntype O = Omit&lt;{ a: number; b: string }, &#39;a&#39;&gt;\n</code></pre></div>',20),s={},c=(0,t(3744).Z)(s,[["render",function(n,e){const t=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[a,(0,r._)("blockquote",null,[(0,r._)("p",null,[i,(0,r._)("a",l,[o,(0,r.Wm)(t)])])]),u],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{for(const[t,r]of e)n[t]=r;return n}}}]);