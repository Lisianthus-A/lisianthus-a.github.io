"use strict";(self.webpackChunkgithub_io=self.webpackChunkgithub_io||[]).push([[958],{6846:(e,a,n)=>{n.r(a),n.d(a,{data:()=>o});const o={key:"v-7cf7059d",path:"/guide/browser.html",title:"浏览器",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"跨域",slug:"跨域",children:[{level:3,title:"原因",slug:"原因",children:[]},{level:3,title:"产生跨域的条件",slug:"产生跨域的条件",children:[]},{level:3,title:"解决方案",slug:"解决方案",children:[]}]}],filePathRelative:"guide/browser.md",git:{updatedTime:1633680119e3}}},7009:(e,a,n)=>{n.r(a),n.d(a,{default:()=>h});var o=n(6252);const t=(0,o.uE)('<h1 id="浏览器" tabindex="-1"><a class="header-anchor" href="#浏览器" aria-hidden="true">#</a> 浏览器</h1><h2 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h2><h3 id="原因" tabindex="-1"><a class="header-anchor" href="#原因" aria-hidden="true">#</a> 原因</h3><p>由于同源策略（Same-origin policy），浏览器会限制非同源的请求。</p><h3 id="产生跨域的条件" tabindex="-1"><a class="header-anchor" href="#产生跨域的条件" aria-hidden="true">#</a> 产生跨域的条件</h3><div class="language-text ext-text"><pre class="language-text"><code>http:  //  example.com  :80\nprotocol      host      port\n协议          主机名     端口\n</code></pre></div><p>源（origin）由协议、主机名、端口组成，当请求的协议、主机名、端口三者任意一个与源不相同时，判断为跨域。</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><h4 id="_1-cors-cross-origin-resource-sharing" tabindex="-1"><a class="header-anchor" href="#_1-cors-cross-origin-resource-sharing" aria-hidden="true">#</a> 1. CORS（Cross-Origin Resource Sharing）</h4><p>后端在响应头加上 <code>Access-Control-Allow-*</code>，告知浏览器允许该请求。</p><p>请求分为简单请求和需预检请求，当请求满足以下条件时就是一个简单请求：</p><ol><li>请求方法为 <code>GET</code>、<code>HEAD</code>、<code>POST</code> 三者之一</li><li>请求头只包括 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li><li>请求头 <code>Content-Type</code> 为 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code> 三者之一</li></ol><p>当请求为需预检请求时，在发送实际请求前，会先发送一个 <code>OPTIONS</code> 请求，由服务器决定实际请求是否被允许。</p><p>部分字段:</p><div class="language-text ext-text"><pre class="language-text"><code>Access-Control-Allow-Origin: http://example.com\n允许请求的源\n\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\n允许请求的方法\n\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\n允许请求头中携带的字段\n\nAccess-Control-Allow-Credentials: true\n是否允许请求携带 Cookies\n\nAccess-Control-Max-Age: 86400\n在 86400 秒内，同一请求无需再次发送预检请求\n</code></pre></div>',15),c=(0,o.Uk)("通过 "),d=(0,o._)("code",null,"Node.js",-1),s=(0,o.Uk)(" 实现代理发送请求，解决跨域问题： "),i={href:"https://github.com/Lisianthus-A/utils-js/blob/main/proxy.js",target:"_blank",rel:"noopener noreferrer"},r=(0,o.Uk)("GitHub 地址"),l=(0,o.uE)('<h4 id="_2-反代理" tabindex="-1"><a class="header-anchor" href="#_2-反代理" aria-hidden="true">#</a> 2. 反代理</h4><p>让同源的服务器对请求做一个转发处理，把跨域请求转为同源请求。</p><h4 id="_3-jsonp-不常用" tabindex="-1"><a class="header-anchor" href="#_3-jsonp-不常用" aria-hidden="true">#</a> 3. JSONP（不常用）</h4><p>利用 <code>script</code> 标签不受同源策略限制来实现跨域。</p><ol><li>在 <code>window</code> 下挂载一个回调函数，如 <code>window.getNumFunc = (num) =&gt; console.log(&#39;num&#39;, num)</code>；</li><li>构造请求地址，传入回调函数的函数名，如 <code>http://example.com/api/getNum?callback=getNumFunc</code>；</li><li>服务端构造函数表达式返回，如 <code>getNumFunc(42)</code>；</li><li>浏览器执行该函数，在控制台打印出 42</li></ol><h4 id="_4-window-name-不常用" tabindex="-1"><a class="header-anchor" href="#_4-window-name-不常用" aria-hidden="true">#</a> 4. window.name（不常用）</h4><p>利用 <code>window.name</code> 在页面跳转后不变的特性。</p><ol><li>用 <code>iframe</code> 加载跨域的页面，设置 <code>window.name</code></li><li>通过 <code>iframe</code> 元素的属性 <code>iframe.contentWindow.name</code> 拿到之前设置的 <code>window.name</code></li></ol><h4 id="_5-document-domain-不常用" tabindex="-1"><a class="header-anchor" href="#_5-document-domain-不常用" aria-hidden="true">#</a> 5. document.domain（不常用）</h4><p>将同一域名下的子域名设置为一级域名实现跨域。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 在 http://a.example.com 页面中设置</span>\ndocument<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">&#39;example.com&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">// 此时可请求一级域名的地址而不会跨域</span>\n<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://example.com/api/getNum</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n</code></pre></div>',11),p={},h=(0,n(3744).Z)(p,[["render",function(e,a){const n=(0,o.up)("OutboundLink");return(0,o.wg)(),(0,o.iD)(o.HY,null,[t,(0,o._)("p",null,[c,d,s,(0,o._)("a",i,[r,(0,o.Wm)(n)])]),l],64)}]])},3744:(e,a)=>{a.Z=(e,a)=>{for(const[n,o]of a)e[n]=o;return e}}}]);